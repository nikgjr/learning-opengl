Rule-10.5		
	The value of an expression should not be cast to an inappropriate essential type	
	The casts which should be avoided are shown in the following table, where values are cast (explicitly converted) to the essential type category of the first column.	
	* Note that an enumerated type may be cast to an enumerated type provided that the cast is to the same essential enumerated type. Such casts are redundant.	
	Casting from void to any other type is not permitted as it results in undefined behaviour. This is covered by Rule 1.3	
		
	표현식의 값을 부적절한 필수 유형으로 변환해서는 안됩니다.	
	피해야 할 형변환은 다음 표에서 볼 수 있습니다. 여기서 값은 첫 번째 열의 필수 유형 범주로 캐스트 (명시 적 변환)됩니다.	
	* 열거 형은 같은 필수 열거 형에 캐스트 인 경우 열거 형으로 형 변환 될 수 있습니다. 이러한 캐스트는 중복됩니다.	
	void에서 다른 유형으로의 캐스팅은 정의되지 않은 동작을 초래하므로 허용되지 않습니다. 이것은 규칙 1.3에 적용됩니다.	
		
	Rule-1.3	
		There shall be no occurrence of undefined or critical unspecified behaviour.
		Some undefined and unspecified behaviours are dealt with by specific rules. This rule prevents all other undefined and critical unspecified behaviours. 
		Appendix H lists the undefined behaviours and those unspecified behaviours that are considered critical.
		
		정의되지 않거나 중대한 불특정 행동의 발생이 없어야한다. 정의되지 않은 동작과 지정되지 않은 동작은 특정 규칙에 따라 처리됩니다. 
		이 규칙은 정의되지 않은 기타 모든 지정되지 않은 동작을 방지합니다. 부록 H는 정의되지 않은 행동과 중요하지 않은 행동을 나열합니다.
		
	Exception:	
	An integer constant expression with the value 0 or 1 of either signedness may be cast to a type which is defined as essentially Boolean. 	
	This allows the implementation of non-C99 Boolean models.	
		
	signedness의 값이 0 또는 1 인 정수 상수 표현식은 본질적으로 bool로 정의 된 유형으로 형변환 될 수 있습니다. 따라서 C99이 아닌 bool 모델을 구현할 수 있습니다.	
		
		
	Example Code:	
		
		#pragma PRQA_MESSAGES_OFF 3112,3408
		
		#include "misra.h"
		#include "m3cmex.h"
		
		
		extern int16_t rule_1005( void )
		{
		    (BL)bla;                                    /*      */
		    (PC)bla;                                    /* 4301 */
		    (N1)bla;                                    /* 4302 */
		    (SI)bla;                                    /* 4303 */
		    (UI)bla;                                    /* 4304 */
		    (FT)bla;                                    /* 4305 */
		
		    (BL)pca;                                    /* 4310 */
		    (PC)pca;                                    /*      */
		    (N1)pca;                                    /* 4312 */
		    (SI)pca;                                    /*      */
		    (UI)pca;                                    /*      */
		    (FT)pca;                                    /* 4315 */
		
		    (BL)n1a;                                    /* 4320 */
		    (PC)n1a;                                    /*      */
		    (N2)n1a;                                    /* 4322 */
		    (SI)n1a;                                    /*      */
		    (UI)n1a;                                    /*      */
		    (FT)n1a;                                    /*      */
		
		    (BL)sia;                                    /* 4330 */
		    (PC)sia;                                    /*      */
		    (N1)sia;                                    /* 4332 */
		    (SI)sia;                                    /*      */
		    (UI)sia;                                    /*      */
		    (FT)sia;                                    /*      */
		
		    (BL)uia;                                    /* 4340 */
		    (PC)uia;                                    /*      */
		    (N1)uia;                                    /* 4342 */
		    (SI)uia;                                    /*      */
		    (UI)uia;                                    /*      */
		    (FT)uia;                                    /*      */
		
		    (BL)fta;                                    /* 4350 */
		    (PC)fta;                                    /* 4351 */
		    (N1)fta;                                    /* 4352 */
		    (SI)fta;                                    /*      */
		    (UI)fta;                                    /*      */
		    (FT)fta;                                    /*      */
		
		    return 0;
		}
		
		
			Rationale
	An explicit cast may be introduced for legitimate functional reasons, for example:
	 To change the type in which a subsequent arithmetic operation is performed;
	 To truncate a value deliberately;
	 To make a type conversion explicit in the interests of clarity.
	However, some explicit casts are considered inappropriate:
	 In C99, the result of a cast or assignment to _Bool is always 0 or 1. This is not necessarily the case when casting to another type which is deÞ ned as essentially Boolean;
	 A cast to an essentially enum type may result in a value that does not lie within the set of enumeration constants for that type;
	 A cast from essentially Boolean to any other type is unlikely to be meaningful;
	 Converting between floating and character types is not meaningful as there is no precise mapping between the two representations.
	이론적 해석
	다음과 같은 적법한 기능적 이유로 명시적인 주조가 도입될 수 있습니다.
	 후속 산술 연산이 수행되는 유형을 변경한다.
	 의도적으로 값을 줄인다.
	 형식 변환을 명확성을 위해 명시적으로 한다.
	
	
( bool_t ) false /* Compliant - C99 'false' is essentially Boolean */	
( int32_t ) 3U /* Compliant */	
( bool_t ) 0 /* Compliant - by exception */	
( bool_t ) 3U /* Non-compliant */	
( int32_t ) ena /* Compliant */	
( enum enuma ) 3 /* Non-compliant */	
( char ) enc /* Compliant */	

-----------------------------------------------------------------------------
* Note: an enumerated type may be cast to an enumerated type provided that the cast is to the same essential enumerated type. Such casts are redundant.
Casting from void to any other type is not permitted as it results in undefined behaviour. This is covered by Rule 1.3.
Rationale
An explicit cast may be introduced for legitimate functional reasons, for example:
 To change the type in which a subsequent arithmetic operation is performed;
 To truncate a value deliberately;
 To make a type conversion explicit in the interests of clarity.
However, some explicit casts are considered inappropriate:
 In C99, the result of a cast or assignment to _Bool is always 0 or 1. This is not necessarily the case when casting to another type which is deÞ ned as essentially Boolean;
 A cast to an essentially enum type may result in a value that does not lie within the set of enumeration constants for that type;
 A cast from essentially Boolean to any other type is unlikely to be meaningful;
 Converting between ß oating and character types is not meaningful as there is no precise mapping between the two representations.
Exception
An integer constant expression with the value 0 or 1 of either signedness may be cast to a type which is defined ned as essentially Boolean. This allows the implementation of non-C99 Boolean models.
Example
( bool_t ) false /* Compliant - C99 'false' is essentially Boolean */
( int32_t ) 3U /* Compliant */
( bool_t ) 0 /* Compliant - by exception */
( bool_t ) 3U /* Non-compliant */
( int32_t ) ena /* Compliant */
( enum enuma ) 3 /* Non-compliant */
( char ) enc /* Compliant */
See also
Rule 10.3, Rule 10.8
-----------------------------------------------------------------------------
Rule-11.4								
	A conversion should not be performed between a pointer to object and an integer type							
	A pointer should not be converted into an integer.							
	An integer should not be converted into a pointer.							
								
	객체에 대한 포인터와 정수 유형 사이의 변환을 수행해서는 안됩니다.							
	포인터는 정수로 변환되지 않아야합니다.							
	정수는 포인터로 변환되지 않아야합니다.							
								
	Exception :							
	A null pointer constant that has integer type may be converted into a pointer to object.							
								
	정수 타입을 갖는 null 포인터 상수는 객체에 대한 포인터로 변환 될 수 있습니다.							
								
	Example Code:							
								
	#pragma PRQA_MESSAGES_OFF 1056,2982,3210,3408,3447							
								
	#include "misra.h"							
	#include "m3cmex.h"							
								
								
	extern volatile uint16_t * pvui;							
	extern          uint16_t * puim;							
								
								
	extern int16_t rule_1104 ( void )							
	{							
	    volatile uint16_t vui = uib;							
	    pvui = (volatile uint16_t *) 0x1234U;                   /* 0303 */							
	    pvui = (volatile uint16_t *) vui;                       /* 0303 */							
								
	    puim = (uint16_t *) 0x1234U;                            /* 0306 */							
	    puim = (uint16_t *) uia;                                /* 0306 */							
	    puim = (uint16_t *) bla;                                /* 0362 */							
								
	    bla = puim;                                             /* 0360 */							
	    bla = (_Bool)puim;                                      /* 0361 */							
								
	    ula = (uint32_t)pvui;                                   /* 0303 */							
	    ula = (uint32_t)puim;                                   /* 0306 */							
								
	    return 0;							
	}							

Rationale
Conversion of an integer into a pointer to object may result in a poin ter that is not correctly aligned, resulting in undefined behaviour.
Conversion of a pointer to object into an integ er may produce a value that cannot be represented in the chosen integer type resulting in undefined behaviour.
Note: the C99 types intptr_t and uintptr_t, declared in <stdint.h>, are respectively signed and unsigned integer types capable of representing pointer values. Despite this, conversions between a pointer to object and these types is not permitted by this rule because their use does not avoid the undefined behaviour associated with misaligned pointers.
Casting between a pointer and an integer type should be avoided where possible, but may be necessary when addressing memory mapped registers or other hardware speciÞ c features. 
If casting between integers and pointers is used, care should be taken to ensure that any pointers produced do not give rise to the undefined behaviour discussed under Rule 11.3.

<이론적 해석>
정수를 객체에 대한 포인터로 변환하면 포인터가 올바르게 정렬되지 않아 정의되지 않은 동작이 발생할 수 있습니다. 
오브젝트에 대한 포인터를 정수로 변환하면 선택된 정수 유형으로 표현 될 수없는 값이 생성되어 정의되지 않은 동작을 초래할 수 있습니다.
<참고>
<stdint.h>에 선언 된 C99 유형 intptr_t 및 uintptr_t는 각각 포인터 값을 나타낼 수있는 부호있는 및 부호없는 정수 유형입니다. 
그럼에도 불구하고 객체에 대한 포인터와 이러한 유형의 변환은 정렬되지 않은 포인터와 관련된 정의되지 않은 동작을 피할 수 없으므로이 규칙에서 허용되지 않습니다. 
가능하면 포인터와 정수 유형 사이의 캐스팅은 피해야하지만, 메모리 맵핑 레지스터 또는 기타 하드웨어 특정 기능을 지정할 때 필요할 수 있습니다. 
정수와 포인터 사이에 캐스팅을 사용하는 경우 생성 된 포인터가 규칙 11.3에 설명 된 정의되지 않은 동작을 발생시키지 않도록주의해야합니다.

< 예외 >
정수 타입을 갖는 널 포인터 상수는 객체에 대한 포인터로 변환 될 수 있습니다.

Exception
A null pointer constant that has integer type may be converted into a pointer to object.

uint8_t *PORTA = ( uint8_t * ) 0x0002; /* Non-compliant */
uint16_t *p;
int32_t addr = ( in t32_t ) &p; /* Non-compliant */
uint8_t *q = ( uint8_t * ) addr; /* Non-compliant */
bool_t b = ( bool_t ) p; /* Non-compliant */
enum etag { A, B } e = ( enum etag ) p; /* Non-compliant */
See also
Rule 11.3, Rule 11.7, Rule 11.9
-----------------------------------------------------------------------------
Rule-11.5													
	A conversion should not be performed from pointer to void into pointer to object												
	void를 가리키는 포인터에서 객체를 가리키는 포인터로 변환하지 마라.												
	포인터에서 void 로의 변환이 객체에 대한 포인터로 수행되어서는 안됩니다.												
	포인터에서 무효 포인터로 개체 변환을 수행하면 안 됩니다.												
													
	Exception:												
	A null pointer constant that has type pointer to void may be converted into pointer to object.												A null pointer constant that has integer type may be converted into a pointer to object.
	void를 가리키는 포인터 타입의 null 포인터 상수는 객체를 가리키는 포인터로 변환 될수 있다.												A null pointer constant that has type pointer to void may be converted into pointer to object.
	void에 대한 포인터 유형을 갖는 null 포인터 상수는 객체에 대한 포인터로 변환 될 수 있습니다.												
	유형 포인터가 무효인 null포인터 상수는 개체에 대한 포인터로 변환될 수 있습니다.												
													
	Example Code:												
													
	#pragma PRQA_MESSAGES_OFF 2982,2983,3408,3447												
													
	#include <stdlib.h>												
	#include "misra.h"												
	#include "m3cmex.h"												
													
	extern int16_t rule_1105( void )												
	{												
	    void * pv = NULL;												
	    int16_t  * pi;												
													
	    pi = (int16_t *)pv;                         /* 0316 */					<-- void를 가리키는 포인터 pv를 int16_t 를 가리키는 포인터로 변환시도							
	    pi =        pv;                             /* 0317 */					<-- void 포인터는 int16_t 포인터에 assign							
	    pi = NULL;                                  /*      */												
	    pi = (void *)0;                             /*      */												
													
	    return 0;												
	}												

Rationale
Conversion of a pointer to void into a pointer to object may result in a pointer that is not correctly aligned, resulting in undefined behaviour. 
It should be avoided where possible but may be necessary, for example when d ealing with memory allocation functions. 
If conversion from a pointer to object into a pointer to void is used, care should be taken to ensure that any pointers produced do not give rise to the undefined behaviour discussed under Rule 11.3.
Exception
A null pointer constant that has type pointer to void may be converted into pointer to object.
Example
uint32_t *p32;
void *p;
uint16_t *p16;
p = p32; /* Compliant - pointer to uint32_t into
* pointer to void */
p16 = p; /* Non-compliant */
p = ( void * ) p16; /* Compliant */
p32 = ( uint32_t * ) p; /* Non-compliant */
See also
Rule 11.2, Rule 11.3
-----------------------------------------------------------------------------
Rule-12.1																	
	The precedence of operators within expressions should be made explicit																
	The following table is used in the definition of this rule.																
	The precedences used in this table are chosen to allow a concise description of the rule. They are not necessarily the same as those that might be encountered in other descriptions of operator precedence.																
	For the purposes of this rule, the precedence of an expression is the precedence of the element (operand or operator) at the root of the parse tree for that expression.																
	For example: the parse tree for the expression a << b + c can be represented as:																
	표현식 내부의 연산자 우선순위는 명확해야 한다.																
	다음표는 이규칙의 정의에 사용된다.																
	이 표에서 사용 된 우선 순위는 규칙에 대한 간결한 설명을 허용하도록 선택됩니다. 연산자 우선 순위에 대한 다른 설명에서 발생할 수있는 것과 반드시 같을 필요는 없습니다.																
	이 규칙의 목적을 위해 표현식의 우선 순위는 해당 표현식에 대한 구문 분석 트리의 루트에서 요소 (피연산자(데이터,값) 또는 연산자)의 우선 순위입니다.																
	예를 들어, 표현식 a << b + c에 대한 구문 분석 트리는 다음과 같이 나타낼 수 있습니다.																
	<<														연산자(operator)		연산을 수행하는 기호
	    /  \														피연산자(operand)		연산에 참여하는 변수/상수
	   a    +														3+7		
	       / \														3(피연산자)+(연산자)7(피연산자)		
	      b   c																
	The element at the root of this parse tree is '<<' so the expression has precedence 10.																
	이 구문 분석 트리의 루트에있는 요소는 '<<'이므로 표현식의 우선 순위가 10이됩니다.																
	The following advice is given:																
	다음 조언이 주어집니다																
	The operand of the sizeof operator should be enclosed in parentheses;																
	An expression whose precedence is in the range 2 to 12 should have parentheses around any operand that has both:																
	Precedence of less than 13, and Precedence greater than the precedence of the expression.																
																	
	sizeof 연산자의 피연산자(데이터,값)는 괄호로 묶어야합니다.																
	우선 순위가 2 - 12 범위 인 표현식은 다음을 모두 갖는 피연산자 주위에 괄호가 있어야합니다.																
	우선 순위가 2~12범위에 있는 표현에는 다음과 같은 피연산자가 모두 포함된 괄호가 있어야 합니다.																
	우선 순위가 13 미만이고 선행은 표현의 우선 순위보다 큽니다.																
	우선 순위는 13보다 작고 우선 순위는 식의 우선 순위보다 큽니다.																
																	
The following table is used in the deÞ nition of this rule.
Description Operator or Operand Precedence
Primary identiÞ er, constant, string literal, ( expression ) 16 (high)
PostÞ x [] () (function call) . -> ++ (post-increment) -- (post-decrement) ()
{} (C99: compound literal) 15
Unary ++ (pre-increment) -- (pre-decrement) & * + - ~ ! sizeof deÞ ned
(preprocessor) 14
Cast () 13
Multiplicative * / % 12
Additive + - 11
Bitwise shift << >> 10
Relational < > <= >= 9
Equality == != 8
Bitwise AND & 7
Bitwise XOR ^ 6
Bitwise OR | 5
Logical AND && 4
Logical OR || 3
Conditional ?: 2
Assignment = *= /= %= += -= <<= >>= &= ^= |= 1
Comma , 0 (low)
The precedences used in this table are chosen to allow a concise description of the rule. They are
not necessarily the same as those that might be encountered in other descriptions of operator
precedence.
For the purposes of this rule, the precedence of an expression is the precedence of the element
(operand or operator) at the root of the parse tree for that expression.
For example: the parse tree for the expression a << b + c can be represented as:
<<
/ \
a +
/ \
b c
The element at the root of this parse tree is '<<' so the expression has precedence 10.
The following advice is given:
 The operand of the sizeof operator should be enclosed in parentheses;
 An expression whose precedence is in the range 2 to 12 should have parentheses around any
operand that has both:
- Precedence of less than 13, and
- Precedence greater than the precedence of the expression.
Rationale
The C language has a relatively large number of operators and their relative precedences are not
intuitive. This can lead less experienced programmers to make mistakes. Using parentheses to
make operator precedence explicit removes the possibility that the programmers expectations are
incorrect. It also makes the original programmers intention clear to reviewers or maintainers of the
code.
It is recognized that overuse of parentheses can clutter the code and reduce its readability. This rule
aims to achieve a compromise between code that is hard to understand because it contains either
too many or too few parentheses.
Examples
The following example shows expressions with a unary or postÞ x operator whose operands are either
primary-expressions or expressions whose top-level operators have precedence 15.
a[ i ]->n; /* Compliant - no need to write ( a[ i ] )->n */
*p++; /* Compliant - no need to write *( p++ ) */
sizeof x + y; /* Non-compliant - write either sizeof ( x ) + y
* or sizeof ( x + y ) */
The following example shows expressions containing operators at the same precedence level. All of
these are compliant but, depending on the types of a, b and c, any expression with more than one
operator may violate other rules.
a + b;
a + b + c;
( a + b ) + c;
a + ( b + c );
a + b - c + d;
( a + b ) - ( c + d );
The following example shows a variety of mixed-operator expressions:
/* Compliant - no need to write f ( ( a + b ), c ) */
x = f ( a + b, c );
/* Non-compliant
* Operands of conditional operator (precedence 2) are:
* == precedence 8 needs parentheses
* a precedence 16 does not need parentheses
* - precedence 11 needs parentheses
*/
x = a == b ? a : a - b;
/* Compliant */
x = ( a == b ) ? a : ( a - b );
/* Compliant
* Operands of << operator (precedence 10) are:
* a precedence 16 does not need parentheses
* ( E ) precedence 16 already parenthesized
*/
x = a << ( b + c );
/* Compliant
* Operands of && operator (precedence 4) are:
* a precedence 16 does not need parentheses
* && precedence 4 does not need parentheses
*/
if ( a && b && c )
{}
/* Compliant
* Operands of && operator (precedence 4) are:
* defined(X) precedence 14 does not need parentheses
* (E) precedence 16 already parenthesized
*/
#if defined ( X ) && ( ( X + Y ) > Z )
/* Compliant
* Operands of && operator (precedence 4) are:
* !defined ( X ) precedence 14 does not need parentheses
* defined ( Y ) precedence 14 does not need parentheses
* Operand of ! operator (precedence 14) is:
* defined ( X ) precedence 14 does not need parentheses
*/
#if !defined ( X ) && defined ( Y )
Note: this rule does not require the operands of a , operator to be parenthesized. Use of the ,
operator is prohibited by Rule 12.3.
x = a, b; /* Compliant - parsed as ( x = a ), b */


The following table is used in the definition of this rule.
The precedences used in this table are chosen to allow a concise description of the rule. 
They are not necessarily the same as those that might be encountered in other descriptions of operator precedence.
다음표는 이규칙의 정의에 사용된다.
이 표에서 사용 된 우선 순위는 규칙에 대한 간결한 설명을 허용하도록 선택됩니다.
연산자 우선 순위에 대한 다른 설명에서 발생할 수있는 것과 반드시 같을 필요는 없습니다.

For the purposes of this rule, the precedence of an expression is the precedence of the element (operand or operator) at the root of the parse tree for that expression.
이 규칙의 목적을 위해 표현식의 우선 순위는 해당 표현식에 대한 구문 분석 트리의 루트에서 요소의 우선 순위입니다. (피연산자(데이터,값) 또는 연산자)
For example: the parse tree for the expression a << b + c can be represented as:
예를 들어, 표현식 a << b + c에 대한 구문 분석 트리는 다음과 같이 나타낼 수 있습니다.
<<
/ 
a +
/ \
b c
The element at the root of this parse tree is '<<' so the expression has precedence 10.
이 구문 분석 트리의 루트에있는 요소는 '<<'이므로 표현식의 우선 순위가 10이됩니다.

The following advice is given:
The operand of the sizeof operator should be enclosed in parentheses;
2) An expression whose precedence is in the range 2 to 12 should have parentheses around any operand that has both:
- Precedence of less than 13, and
- Precedence greater than the precedence of the expression.
다음과 같은 조언이 제공됩니다.
sizef연산자의 피연산자는 괄호 안에 넣어야 한다.
우선 순위가 2 - 12 범위 인 표현식은 다음을 모두 갖는 피연산자 주위에 괄호가 있어야합니다.
13 미만의 우선순위
표현식의 우선순위 보다 큰 우선순위


Rationale
The C language has a relatively large number of operators and their relative precedences are not intuitive. 
This can lead less experienced programmers to make mistakes. 
Using parentheses to make operator precedence explicit removes the possibility that the programmer's expectations are incorrect. 
It also makes the original programmer's intention clear to reviewers or maintainers of the code.
It is recognized that overuse of parentheses can clutter the code and reduce its readability. 
This rule aims to achieve a compromise between code that is hard to understand because it contains either too many or too few parentheses.
C 언어는 상대적으로 많은 수의 연산자를 가지며 상대적인 우선 순위는 직관적이지 않습니다. 이로 인해 경험이 부족한 프로그래머는 실수를 저지를 수 있습니다.
괄호를 사용하여 연산자 우선 순위를 명시 적으로 지정하면 프로그래머의 예상이 부정확할 가능성이 없어집니다. 
또한 원래 프로그래머의 의도를 검토 자나 코드 관리자에게 분명하게 알려줍니다.
괄호를 과도하게 사용하면 코드가 복잡해지고 가독성이 떨어질 수 있습니다.
이 규칙은 너무 많거나 적은 괄호를 포함하고 있기 때문에 이해하기 어려운 코드간에 절충안을 작성하는 것을 목표로합니다.
<예제>
The following example shows expressions with a unary or postfix operator whose operands are either primary-expressions or expressions whose top-level operators have precedence 15.
다음 예에서는 피연산자가 기본 표현식이거나 최상위 연산자가 15번째인 표현식을 사용하는 표현식을 보여 줍니다.
다음 예제는 피연산자가 기본 표현식이거나 최상위 연산자가 우선 순위가 15 인 단항 또는 후행 연산자가있는 표현식을 보여줍니다.
a[ i ]->n;       /* Compliant - no need to write ( a[ i ] )->n */
*p++;           /* Compliant - no need to write *( p++ ) */
sizeof x + y;   /* Non-compliant - write either sizeof ( x ) + y or sizeof ( x + y ) */

The following example shows expressions containing operators at the same precedence level. 
All of these are compliant but, depending on the types of a, b and c, any expression with more than one operator may violate other rules.
다음 예제에서는 동일한 우선 순위 수준에있는 연산자가 포함 된 표현식을 보여줍니다. 
이들 모두는 준수하지만 a, b 및 c의 유형에 따라 둘 이상의 운영자가있는 표현은 다른 규칙을 위반할 수 있습니다.
a + b;
a + b + c;
( a + b ) + c;
a + ( b + c );
a + b - c + d;
( a + b ) - ( c + d );

The following example shows a variety of mixed-operator expressions:
다음 예제는 다양한 혼합 연산자 표현식을 보여줍니다.

x = a == b ? a : a - b;
Operands of conditional operator (precedence 2) are '==' precedence 8 needs parentheses a precedence 16 does not need parentheses '-' precedence 11 needs parentheses.
조건 연산자 (우선 순위 2)의 피연산자는 '=='우선 순위 8 개 괄호가 필요 우선 순위 16 개는 괄호가 필요 없음 '-'우선 순위 11은 괄호가 필요합니다.
/* Compliant */
x = ( a == b ) ? a : ( a - b );

/* Compliant
* Operands of << operator (precedence 10) are a precedence 16 does not need parentheses ( E ) precedence 16 already parenthesized.
*/
x = a << ( b + c );
/* Compliant
* Operands of && operator (precedence 4) are a precedence 16 does not need parentheses '&&' precedence 4 does not need parentheses.
*/
if ( a && b && c )
{}
/* Compliant
* Operands of && operator (precedence 4) are defined(X) precedence 14 does not need parentheses (E) precedence 16 already parenthesized.
*/
#if defined ( X ) && ( ( X + Y ) > Z )
/* Compliant
* Operands of && operator (precedence 4) are !defined ( X ) precedence 14 does not need parentheses defined ( Y ) precedence 14 does not need parentheses.
 Operand of ! operator (precedence 14) is defined ( X ) precedence 14 does not need parentheses.
*/
#if !defined ( X ) && defined ( Y )
Note: this rule does not require the operands of a , operator to be parenthesized. Use of the ,
operator is prohibited by Rule 12.3.
x = a, b; /* Compliant - parsed as ( x = a ), b */

-----------------------------------------------------------------------------
Rule-12.3									가독성 저하	
										
	The comma operator should not be used									
	쉽표 연산자는 사용하지 않아야 한다.									
										
	Example Code:									
										
	#pragma PRQA_MESSAGES_OFF 2984									
										
	#include "misra.h"									
	#include "m3cmex.h"									
										
	#define A (-5)									
	#define B 3									
										
	extern int16_t rule_1203( void )									
	{									
	   int16_t x;									
	   int16_t y;									
	   int16_t i;									
										
	   y = ( x = A, x + B );              /* 3417 3226 */						<-- y = ( A + B ) ==> y = -2			
										
	   for ( i = 0, ++y; i < B; ++i )     /* 3418      */									
	   {									
	      ++y;									
	   }									
										
	   return y;									
	}									
										
										
	#include <stdio.h>  									
	int main () {  									
	   int i = 10, b = 20, c= 30;  					int I, j;		int I, j;		int I, j;
	   i = b, c;  					I = 0;		j = (I = 0, I + 2);		j = I = 0, I + 2;
	   printf("%i\n", i);  					j = I + 2';				
	  									
	   i = (b, c);  									
	   printf("%i\n", i);  									
	}  									
										
	20									
	30									

	
	Rationale
Use of the comma operator is generally detrimental to the readability of code, and the same effect can usually be achieved by other means.
쉼표 연산자를 사용하면 일반적으로 코드 가독성이 떨어지며 다른 방법으로도 동일한 효과를 얻을 수 있다.
쉼표 연산자의 사용은 일반적으로 코드의 가독성에 해를 끼치며 일반적으로 다른 방법을 통해 동일한 효과를 얻을 수 있습니다.

f ( ( 1, 2 ), 3 ); /* Non-compliant - how many parameters? */
The following example is non-compliant with this rule and other rules:
다음 예제는이 규칙 및 기타 규칙을 준수하지 않습니다.
for ( i = 0, p = &a[ 0 ]; i < N; ++i, ++p )
{}



-----------------------------------------------------------------------------
Rule-12.4													
	Evaluation of constant expressions should not lead to unsigned integer wrap-around												
	상수 표현의 평가는 부호없는 정수를 둘러 싸서는 안됩니다												
													
	This rule applies to expressions that satisfy the constraints for a constant-expression, whether or not they appear in a context that requires a constant-expression.												
	If an expression is not evaluated, for example because it appears in the right operand of a logical AND operator whose left operand is always false, then this rule does not apply.												
	이 규칙은 상수 표현식이 필요한 컨텍스트에 표시되는지 여부에 관계없이 상수 식에 대한 제약 조건을 충족시키는 식에 적용됩니다.												
	표현식이 평가되지 않으면 (예 : 왼쪽 피연산자가 항상 false 인 논리 AND 연산자의 오른쪽 피연산자에 나타나기 때문에)이 규칙은 적용되지 않습니다.												
													
													
	Example Code:												
													
	#pragma PRQA_MESSAGES_OFF 2982,2984												
													
	#include "misra.h"												
	#include "m3cmex.h"												
													
	#define BASE  65024u												
	#define DELAY 10000u												
	#define WIDTH 60000u												
													
	extern int16_t rule_1204( void )												
	{												
	   static const uint16_t cy = 0xffffu;												
													
	   u32a = 0x1U - 0x2U;                    /* 2910 */					<-- 음수							
													
	   u32a = 0xFFFFFFFFU + 0x2U;             /* 2910 */					<-- 움수							
	   u32a = 0xFFFFU + 0x2U;                 /* 2910 */					<--?							
	   u32a = 0xFFU + 0x2U;												
													
	   u32a = 0x0FFFFFFFU * 32U;              /* 2910 */					<-- 음수							
	   u32a = 0x0FFFU * 32U;                  /* 2910 */					<--?							
	   u32a = 0x0FU * 32U;												
													
	   switch (u16a)												
	   {												
	   case BASE + 0u:   ++u16a; break;												
	   case BASE + 1u:   ++u16b; break;												
	   case BASE + 512u: ++u16r; break;       /* 2910 */					<-- 음수							
	   default:                break;												
	   }												
													
	#if 1u + (0u - 10u)                       /* 2910 */					<-- 음수							
	#endif												
													
	   u16a = DELAY + WIDTH;                  /* 2910 */					<-- 음수, over 65535							
													
	   u16b = cy + 1u;                        /*      */												
													
	   u16c = (0u == 0u) ? 0u : (0u - 1u);    /* 2910 */      /* Compliant - but operation is unreachable */												
													
	   u16d = bla ? 0u : (0u - 1u);           /* 2910 */					<-- bla가 false면 음수 assign							
													
	   return 0;												
	}												

Rationale
Unsigned integer expressions do not strictly overflow, but instead wrap-around. 
Although there may be good reasons to use modulo arithmetic at run-time, it is less likely for its use to be intentional at compile-time.
부호없는 정수 표현은 오버플로가 아니라 오버랩됩니다.
런타임에 모듈로 산술을 사용하는 데는 충분한 이유가있을 수 있지만, 컴파일 타임에 의도적으로 사용할 가능성은 적습니다.

Example
The expression associated with a case label is required to be a constant expression. 
If an unsigned wraparound occurs during evaluation of a case expression, it is likely to be unintentional. 
On a machine with a 16-bit int type, any value of BASE greater than or equal to 65024 would result in wrap-around in the following example:
사례 레이블과 관련된 표현식은 상수 표현식이어야합니다.
사례 표현을 평가하는 동안 부호없는 둘러 감기가 발생하면 의도하지 않은 것일 수 있습니다.
16 비트 int 유형이있는 시스템에서 BASE가 65024보다 크거나 같으면 다음 예에서 랩 어라운드가 발생합니다.
#define BASE 65024u
switch ( x )
{
case BASE + 0u:
f ( );
break;
case BASE + 1u:
g ( );
break;
case BASE + 512u: /* Non-compliant - wraps to 0 */
h ( );
break;
}

The controlling expression of a #if or #elif preprocessor directive is required to be a constant expression.
#if , #elif 전처리문의 조건식은 상수식이어야 함.

#if 1u + ( 0u - 10u ) /* Non-compliant as ( 0u - 10u ) wraps */

In this example, the expression DELAY + WIDTH has the value 70000 but this will wrap-around to 4464 on a machine with a 16-bit int type.
이 예제에서 DELAY+WISpH표현식의 값은 70000이지만 16비트 삽입 유형의 시스템에서는 4464로 바뀝니다.

#define DELAY 10000u
#define WIDTH 60000u
void fixed_pulse ( void )
{
uint16_t off_time16 = DELAY + WIDTH; /* Non-compliant */
}

This rule does not apply to the expression c + 1 in the following compliant example as it accesses an object and therefore does not satisfy the constraints for a constant expression:
이 규칙은 객체를 액세스하므로 상수 표현식에 대한 제약 조건을 충족시키지 않으므로 다음의 호환 예제에서 표현식 c + 1에 적용되지 않습니다.

const uint16_t c = 0xffffu;
void f ( void )
{
uint16_t y = c + 1u; /* Compliant */
}

In the following example, the sub-expression ( 0u - 1u ) leads to unsigned integer wrap-around. 
In the initialization of x, the sub-expression is not evaluated and the expression is therefore compliant.
However, in the initialization of y, it may be evaluated and the expression is therefore non-compliant.
다음 예에서 하위 표현식 (0u - 1u)은 부호없는 정수로 둘러 쌉니다.
x의 초기화에서 하위 표현식은 평가되지 않으므로 표현식이 호환됩니다.
그러나, y의 초기화에서, 그것은 평가 될 수 있고 표현은 비 호환적일 수있다.

bool_t b;
void g ( void )
{
uint16_t x = ( 0u == 0u ) ? 0u : ( 0u - 1u ); /* Compliant */
uint16_t y = b ? 0u : ( 0u - 1u ); /* Non-compliant */
}
-----------------------------------------------------------------------------
Rule-13.3					
	A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator				
	증가 (++) 또는 감소 (-) 연산자를 포함하는 전체 표현식은 증가 또는 감소 연산자로 인해 야기된 것 이외의 잠재적인 다른 부작용이 없어야합니다				
					
	A function call is considered to be a side effect for the purposes of this rule.				
	All sub-expressions of the full expression are treated as if they were evaluated for the purposes of this rule, even if specified as not being evaluated by The Standard.				
	함수 호출은이 규칙의 목적 상 부작용으로 간주됩니다.				
	전체 표현식의 모든 하위 표현식은 표준에 의해 평가되지 않는 것으로 지정된 경우에도이 규칙의 목적에 따라 평가 된 것처럼 취급됩니다.				
					
	#pragma PRQA_MESSAGES_OFF 2982,2983,2984				
					
	#include "misra.h"				
	#include "m3cmex.h"				
					
	struct XS				
	{				
	    int16_t a;				
	    int16_t b;				
	};				
					
					
	extern int16_t rule_1303( void )				
	{				
	   int16_t x = 0;				
	   int16_t r;				
	   int16_t buf[10] = {0};				
	   int16_t *psi;				
	   struct XS xsa = {0};				
	   struct XS *ps;				
					
	   ++x;				
	   x++;				
	   --x;				
	   x--;				
					
	   r = ++x;                    /* 3440 */				r = ++x : x = 0x1, (1), r = 0x1
	   r = x++;                    /* 3440 */				r = x++ : x = 0x2, (2), r = 0x1
	   r = --x;                    /* 3440 */				r = --x : x = 0x1, (1), r = 0x1
	   r = x--;                    /* 3440 */				r = x-- : x = 0x0, (0), r = 0x1
					
	   buf[0]++;				
	   xsa.a++;				
	   ps = &xsa;				
	   ps->a++;				
	   psi = &buf[5];				
	   (*psi)++;				
					
	   return r;				
	}				

Rationale
The use of increment and decrement operators in combination with otheroper ators is not recommended because:
 - It can significantly impair the readability of the code;
 - It introduces additional side effects into a statement with the potential for undefined behaviour.
(covered by Rule 13.2).
It is clearer to use these operations in isolation from any other operators.
다른 연산자와 조합하여 증가 및 감소 연산자를 사용하는 것은 권장되지 않습니다. 그 이유는 다음과 같습니다.
 - 코드의 가독성을 크게 손상시킬 수 있습니다.
 - 정의되지 않은 동작이 발생할 가능성이있는 문에 추가 부작용을 도입합니다.
Example
The expression:
u8a = u8b++
is non-compliant. The non-compliant expression statement:
u8a = ++u8b + u8c--;
is clearer when written as the following sequence:
++u8b;
u8a = u8b + u8c;
u8c--;
The following are all compliant because the only side e ect in each expression is caused by the increment or decrement operator.
x++;
a[ i ]++;
b.x++;
c->x++;
++( *p );
*p++;
( *p )++;

The following are all non-compliant because they contain a function call as well as an increment or decrement operator:
if ( ( f ( ) + --u8a ) == 0u )
{}
g ( u8b++ );
The following are all non-compliant even though the sub-expression containing the increment or decrement operator or some other side effect is not evaluated:
증가 또는 감소 연산자 또는 다른 부작용이 포함 된 하위 표현식이 평가되지 않더라도 다음은 모두 비준수입니다.
u8a = ( 1u == 1u ) ? 0u : u8b++;
if ( u8a++ == ( ( 1u == 1u ) ? 0u : f ( ) ) )
{}
See also
Rule 13.2
-----------------------------------------------------------------------------
Rule-13.4											
	The result of an assignment operator should not be used										
	대입 연산자의 결과는 사용하지 않아야합니다.										
											
	This rule applies even if the expression containing the assignment operator is not evaluated.										
	이 규칙은 대입 연산자가 포함 된 표현식이 평가되지 않은 경우에도 적용됩니다.										
											
	Example Code:										
											
	#include <stdbool.h>										
	#include "misra.h"										
	#include "m3cmex.h"										
											
											
	extern int16_t rule_1304( void )										
	{										
	    int16_t buf[10] = {0};										
											
	    buf[u16a] = buf[u16b = u16c];               /* 3226           */						<-- u16b=u16c 에 의해 배열 인덱스가 9를 넘을수 있슴.				
											
	    if ( bla = false )                          /* 3326      2992 */						<-- 조건문자리에 대입연산자 : if문 무조건 true				
	    {										
	    }										
											
	    if ((0u == 0u) || (bla = true))             /* 3326 3415 2991 */										
	    {										
	    }										
											
	    if ( ( uia = get_u16() ) != 0u)             /* 3326           */										
	    {										
	    }										
											
	    buf[ u16a += u16b ] = buf [ u16c ];         /* 3226           */										
											
	    s16a = s16b = s16c = 0;                     /* 3226 3226      */										
											
	    return 1;										
	}										

Rationale
The use of assignment operators, simple or compound, in combination with other arithmetic operators is not recommended because:
- It can significantly impair the readability of the code;
- It introduces additional side effects into a statement making it more di cult to avoid the undefined behaviour covered by Rule 13.2.
다음과 같은 이유로 다른 산술 연산자와 함께 할당 연산자 (단순 또는 복합 연산자)를 사용하지 않는 것이 좋습니다.
- 코드의 가독성을 크게 손상시킬 수 있습니다.
- 규칙 13.2에서 다루지 않은 정의되지 않은 동작을 피하기 위해 부작용을 추가 진술로 소개합니다.
Example
x = y; /* Compliant */
a[ x ] = a[ x = y ]; /* Non-compliant - the value of x = y is used */
/*
* Non-compliant - value of bool_var = false is used but bool_var == false was probably intended.
*/
if ( bool_var = false )
{}
/* Non-compliant even though bool_var = true isn't evaluated */
if ( ( 0u == 0u ) || ( bool_var = true ) )
{}
/* Non-compliant - value of x = f() is used */
if ( ( x = f ( ) ) != 0 )
{}
/* Non-compliant - value of b += c is used */
a[ b += c ] = a[ b ];
/* Non-compliant - values of c = 0 and b = c = 0 are used */
a = b = c = 0;
See also
Rule 13.2
-----------------------------------------------------------------------------
Rule-15.1	
	The goto statement should not be used
	
	Example Code:
	
	#include "misra.h"
	#include "m3cmex.h"
	
	extern int16_t rule_1501( void )
	{
	   goto mylabel;                        /* 2001 */
	
	mylabel:
	
	   return 1;
	}

	Rationale
Unconstrained use of goto can lead to programs that are unstructured and extremely difficult to understand.
In some cases a total ban on goto requires the introduction of flags to ensure correct control flow, and it is possible that these flags may themselves be less transparent than the goto they replace.
Therefore, if this rule is not followed, the restricted use of goto is allowed where that use follows the guidance in Rule 15.2 and Rule 15.3.
제약없이 사용할 수있는 고토 (goto)를 사용하면 이해하기 어려운 구조의 프로그램으로 이어질 수 있습니다.
경우에 따라 goto를 완전히 금지하려면 정확한 제어 흐름을 보장하는 플래그가 필요하며이 플래그 자체가 대체하는 goto보다 투명하지 않을 수도 있습니다.
따라서이 규칙을 준수하지 않을 경우 goto의 제한 사용은 규칙 15.2 및 규칙 15.3의 지침을 따르는 경우 허용됩니다.
따라서, 이 규칙을 따르지 않을 경우, 제152조 및 규칙 15.3항의 지침에 따라 구토를 제한적으로 사용할 수 있다.
See also
Rule 9.1, Rule 15.2, Rule 15.3, Rule 15.4
-----------------------------------------------------------------------------
Rule-15.4							
	There should be no more than one break or goto statement used to terminate any iteration statement						
	반복 루프문을 종료하는데 사용되는 break 또는 goto 문은 하나만 있어야 한다. 단일 break 또는 단일 goto						
							
	Example Code:						
							
	#include "misra.h"						
	#include "m3cmex.h"						
							
							
	extern int16_t rule_1504( void )						
	{						
	   int16_t m;						
	   int16_t n;						
							
	   for ( n = 0; n < 5; n++ )						
	   {						
	      if ( n > s16a )						
	      {						
	         break;						
	      }						
							
	      switch (s16a)						
	      {						
	      case 1:						
	         ++s16b;						
	         break;						
	      case 2:						
	         if (s16b > s16a)						
	         {						
	            break;						
	         }						
	         ++s16b;						
	         break;						
	      default:						
	         break;						
	      }						
							
	      if ( n > (s16a - 2) )						
	      {						
	         break;                                                 /* 0771 */						<-- for 루프 종료조건 n값이 s16a 이상인지, s16a-2 이상인지 구분불가
	      }						
							
	   }						
							
	   /* Both of the following nested loops are compliant as each has a single break used for early loop termination. */						
							
	   for ( m = 0; m < 10; ++m )						
	   {						
	      if ( get_bool() )						
	      {						
	         break;						
	      }						
							
	      for ( n = 0; n < m; ++n )						
	      {						
	         if ( get_bool() )						
	         {						
	            break;						
	         }						
	      }						
	   }						
							
	   /* The following loop is non-compliant as there are multiple break and goto statements used for early loop termination. */						
							
	   for ( m = 0; m < 10; ++m )						
	   {						
	      if ( get_bool() )						
	      {						
	         break;						
	      }						
	      else if ( get_bool() )						
	      {						
	         goto EXIT;                                             /* 2001 */      /* Non-compliant */						
	      }						
	      else						
	      {						
	         s16b = get_s16();						
	      }						
	   }						
							
							
	   /* In the following example, the inner while loop is compliant because there is a single goto statement that can cause its early termination.
	      However, the outer while loop is non-compliant because it can be terminated early either by the break statement or by the goto statement in the inner while loop. */
							
	   while (m != 0)						
	   {						
	      m = get_s16();						
							
	      if (m == 1)						
	      {						
	         break;						
	      }						
							
	      while (n != 0)						
	      {						
	         n = get_s16();						
	         if (n == 1)						
	         {						
	            goto EXIT;                                          /* 2001 */      /* Non-compliant */						
	         }						
	      }						
	   }						
							
	   EXIT:						
	   return s16b;						
	}						

Rationale
Restricting the number of exits from a loop helps to minimize visual code complexity. 
The use of one break or goto statement allows a single secondary exit path to be created when early loop termination is required.
루프의 이탈 수를 제한하면 시각적 코드의 복잡성을 최소화 할 수 있습니다. 
하나의 break 또는 goto 문을 사용하면 초기 루프 종료가 필요할 때 단일 보조 종료 경로를 작성할 수 있습니다.
Example
Both of the following nested loops are compliant as each has a single break used for early loop termination.
 다음 중첩 루프는 모두 초기 루프 종료에 사용되는 단일 브레이크가 있으므로 준수합니다.
for ( x = 0; x < LIMIT; ++x )
{
    if ( ExitNow ( x ) )
    {
         break;
    }
    for ( y = 0; y < x; ++y )
    {
        if ( Exit Now ( LIMIT - y ) )
        {
            break;
        }
    }
}
The following loop is non-compliant as there are multiple break and goto statements used for early loop termination.
초기 루프 종료에 사용되는 break 및 goto 문이 여러 개 있기 때문에 다음 루프가 호환되지 않습니다
for ( x = 0; x < LIMIT; ++x )
{
     if ( BreakNow ( x ) )
     {
          break;          /* non-compliant */
     }
     else if ( GotoNow ( x ) )
     {
          goto EXIT;     /* non-compliant */
     }
     else
     {
          KeepGoing ( x );
     }
}
EXIT:

	
In the following example, the inner while loop is compliant because there is a single goto statement that can cause its early termination. 
However, the outer while loop is non-compliant because it can be terminated early either by the break statement or by the goto statement in the inner while loop.
다음 예제에서 내부 while 루프는 일찍 종료 될 수있는 단일 goto 문이 있기 때문에 호환됩니다.
그러나 outer while 루프는 break 문이나 inner while 루프의 goto 문에 의해 일찍 종료 될 수 있기 때문에 호환되지 않습니다.
while ( x != 0u )
{
   x = calc_new_x ( );
   if ( x == 1u )
   {
      break;
   }
   while ( y != 0u )
   {
      y = calc_new_y ( );
      if ( y == 1u )
      {
         goto L1;
      }
   }
}
L1:
z = x + y;
See also
Rule 15.1, Rule 15.2, Rule 15.3
-----------------------------------------------------------------------------
Rule-15.5												
	A function should have a single point of exit at the end											
	함수는 끝에 단일 종료 점을 가져야합니다.											
												
												
	A function should have no more than one return statement.											
	When a return statement is used, it should be the final statement in the compound statement that forms the body of the function.											
	함수는 하나 이상의 return 문을 가져야합니다.											
	return 문을 사용할 때는 함수 본문을 구성하는 복합 문에서 마지막 문이어야합니다.											
												
												
	Example Code:											
												
	#include "misra.h"											
	#include "m3cmex.h"											
												
												
	extern int16_t rule_1505( void )                                /* 2889 */											
	{											
	   if ( s16a > 0 )											
	   {											
	      return 0;											
	   }											
	   else											
	   {											
	      return 1;											
	   }											
	}											

	Rationale
A single point of exit is required by IEC61508 and ISO26262 as part of the requirements for a modular approach.
Early returns may lead to the unintentional omission of function termination code.
If a function has exit points interspersed with statements that produce persistent side effects, it is not easy to determine which side effects will occur when the function is executed.
단일 접근 점은 모듈 방식의 요구 사항의 일부로서 IEC61508 및 ISO26262에서 요구됩니다.
조기 리턴은 실수로 기능 종료 코드가 누락 될 수 있습니다.
함수에 종료 부작용이 나타나는 명령문이 산재되어 있으면 함수가 실행될 때 발생할 부작용을 판별하기 쉽지 않습니다.
Example
In the following non-compliant code example, early returns are used to validate the function parameters.
다음의 비 호환 코드 예제에서 함수 매개 변수의 유효성을 검사하는 데 초기 리턴이 사용됩니다
bool_t f ( uint16_t n, char *p )
{
    if ( n > MAX )
    {
         return false;
    }
    if ( p == NULL )
    {
         return false;
    }
    return true;
}

See also
R ule 17.4

-----------------------------------------------------------------------------
Rule-17.5	
	The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements.
	배열 형을 가지는 것으로 선언 된 파라미터에 대응하는 함수 인수는 적절한 수의 요소를 가져야한다.
	
	If a parameter is declared as an array with a specified size, the corresponding argument in each function call should point into an object that has at least as many elements as the array.
	매개 변수가 지정된 크기의 배열로 선언 된 경우 각 함수 호출의 해당 인수는 적어도 배열만큼 요소가있는 개체를 가리켜야합니다.
	
	Example Code:
	
	 "
	/* Intent is that function does not access outside the range array1[0]....[3]. */
	void fn1 (int32_t array1[4]);
	
	/* Intent is that function handles arrays of any size. */
	void fn2 (int32_t array2[]);
	
	void fn (int32_t *ptr);
	{
	 int32_t arr3 [3] = {1, 2, 3};
	 int32_t arr4 [4] = {0, 1, 2, 3};
	
	 /* Compliant - size of array matches the prototype */
	 fn1 (arr4);
	
	 /* Non-compliant - size of array does not match the prototype */
	 fn1 (arr3);
	
	 /* Compliant only if ptr points to at least 4 elements */
	 fn1 (ptr);
	
	 /* Compliant */
	 fn2 (arr4);
	
	 /* Compliant */
	 fn2 (ptr);
	}
Rationale
The use of an array declarator for a function parameter specifies the f unction interface more clearly than using a pointer. 
The minimum number of elements expected by the function is explicitly stated, whereas this is not possible with a pointer.
A function parameter array declarator which does not specify a size is assumed to indicate that the function can handle an array of any size. 
In such cases, it is expected that the array size will be communicated by some other means, for example by being passed as another parameter, or by terminating the array with a sentinel value.
The use of an array bound is recommended as it allows out-of-bounds checking to be implemented within the function body and extra checks on parameter passing. 
It is legal in C to pass an array of the incorrect size to a parameter with a specified size, which can lead to unexpected behaviour.

함수 매개 변수에 배열 선언자를 사용하면 포인터를 사용하는 것보다 함수 인터페이스를 더 명확하게 지정할 수 있습니다.
함수가 예상하는 최소 요소 수는 명시 적으로 명시되어 있지만 포인터로는 불가능합니다.
크기를 지정하지 않는 함수 매개 변수 배열 선언자는 함수가 임의의 크기의 배열을 처리 할 수 ​​있음을 나타냅니다.
이러한 경우 배열 크기는 다른 매개 변수로 전달되거나 센티넬 값으로 배열을 종료하는 등의 다른 방법으로 전달됩니다.
함수 범위 내에서 범위 외 검사를 구현하고 매개 변수 전달에 대한 추가 검사를 허용하므로 배열 경계를 사용하는 것이 좋습니다.
어레이 바인딩을 사용하면 함수 본문 내에서 경계 이탈 검사를 구현하고 매개 변수 전달에 대한 추가 검사를 수행할 수 있으므로 권장됩니다. 
C에서 잘못된 크기의 배열을 지정된 크기의 매개 변수로 전달하면 예기치 않은 동작이 발생할 수 있습니다.

Example

/* Intent is that function does not access outside the range array1[ 0 ] .. array1[ 3 ]. */
void fn1 ( int32_t array1[ 4 ] );
/* Intent is that function handles arrays of any size. */
void fn2 ( int32_t array2[ ] );
void fn ( int32_t *ptr )
{
   int32_t arr3[ 3 ] = { 1, 2, 3 };
   int32_t arr4[ 4 ] = { 0, 1, 2, 3 };
   /* Compliant - size of array matches the prototype. */
   fn1 ( arr4 );
   /* Non-compliant - size of array does not match prototype. */
   fn1 ( arr3 );
   /* Compliant only if ptr points to at least 4 elements. */
   fn1 ( ptr );
   /* Compliant */
   fn2 ( arr4 );
   /* Compliant */
   fn2 ( ptr );
}
See also
Rule 17.6

-----------------------------------------------------------------------------
Rule-17.8		
	A function parameter should not be modified.	
		
	Example Code:	
		
	#include "misra.h"	
	#include "m3cmex.h"	
		
	static int16_t rule_1708a(int16_t p);	
		
	extern int16_t rule_1708( void )	
	{	
	    s16a = rule_1708a(5);	
		
	    return 1;	
	}	
		
	static int16_t rule_1708a(int16_t p)	
	{	
	    ++p;                                        	/* Not compliant */ --> (*p)++;
		
	    return(p);	
	}	

Rationale
A function parameter behaves in the same manner as an object that has automatic storage duration.
While the C language permits parameters to be modified, such use can be confusing and conflict with programmer expectations. 
It may be less confusing to copy the parameter to an automatic object and modify that copy. 
With a modern compiler, this will not usually result in any storage or execution time penalty.

Programmers who are unfamiliar with C, but who are used to other languages, may modify a parameter believing that the e ects of the modification will be felt in the calling function.

이론적 해석
함수 매개 변수는 자동 저장 기간이있는 객체와 동일한 방식으로 동작합니다.
C 언어는 매개 변수 수정을 허용하지만 이러한 사용은 프로그래머의 기대와 혼동되고 충돌 할 수 있습니다.
매개 변수를 자동 개체에 복사하고 해당 복사본을 수정하는 것이 덜 혼동스럽지 않을 수 있습니다.
최신 컴파일러를 사용하면 일반적으로 저장 또는 실행 시간에 불이익을 초래하지 않습니다.
C에 익숙하지 않지만 다른 언어에 익숙한 프로그래머는 수정의 효과가 호출 함수에서 느껴질 것이라고 생각하는 매개 변수를 수정할 수 있습니다.

Example
int16_t glob = 0;
void proc ( int16_t para )
{
   para = glob; /* Non-compliant */
}
void f ( char *p, char *q )
{
   p = q; /* Non-compliant */
   *p = *q; /* Compliant */
}
-----------------------------------------------------------------------------
Rule-18.4									
	The +, -, += and -= operators should not be applied to an expression of pointer type								
	+, -, + = 및 - = 연산자는 포인터 유형의 표현식에 적용하면 안됩니다.								
									
	Exception:								
	Subject to Rule-18.2, pointer subtraction between two pointers is allowed.								
									Array indexing using the array subscript syntax , ptr[expr], is the preferred form of pointer arithmetic because it is often clearer and hence less error prone than pointer manipulation. 
									Any explicitly calculated pointer value has the potential to access unintended or invalid memory addresses. 
	Example Code:								Such behaviour is also possible with array indexing, but the subscript syntax may ease the task of manual review.
									Pointer arithmetic in C can be confusing to the novice. 
	#include "misra.h"								The expression ptr+1 may be mistakenly interpreted as the addition of 1 to the address held in ptr. 
	#include "m3cmex.h"								In fact the new memory address depends on the size in bytes of the pointers target. 
									This misunderstanding can lead to unexpected behaviour if sizeof is applied incorrectly.
	extern int16_t rule_1804( void )								When used with caution however, pointer manipulation using ++ can in some cases be considered more natural; 
	{								e.g. sequentially accessing locations during a memory test where it is more convenient to treat the memory space as a contiguous set of locations and the address bounds can be determined at compilation time. 
	    uint8_t ax[ 20 ];								
	    uint8_t * ptr;								배열 첨자 구문 인 ptr [expr]을 사용한 배열 색인화는 포인터 조작보다 더 명확하고 오류가 적기 때문에 포인터 계산의 기본 형식입니다.
									명시 적으로 계산 된 포인터 값은 의도하지 않거나 유효하지 않은 메모리 주소에 액세스 할 가능성이 있습니다.
	    ptr = ax;								이러한 동작은 배열 인덱싱에서도 가능하지만 아래 첨자 구문을 사용하면 수동 검토 작업이 쉬워 질 수 있습니다.
									C에서의 포인터 연산은 초보자에게 혼동을 줄 수 있습니다.
	    ptr ++;                                                     /*      */      /* Compliant     */								표현 ptr + 1은 실수로 ptr에 보유 된 주소에 1을 더한 것으로 해석 될 수 있습니다.
	    ptr = ptr + 1;                                              /*      */      /* Non-compliant */								사실 새 메모리 주소는 포인터의 대상 바이트 크기에 따라 다릅니다.
									sizeof가 잘못 적용되면 이러한 오해로 인해 예기치 않은 동작이 발생할 수 있습니다.
	    ptr = ptr + 5;                                              /* 0488 */      /* Non-compliant */								그러나주의해서 사용하면 ++를 사용하는 포인터 조작이 더 자연스러운 것으로 간주 될 수 있습니다.
	    *( ptr + 5 ) = 0U;                                          /* 0488 */      /* Non-compliant */								예 : 메모리 테스트 동안 메모리 액세스를 순차적으로 액세스하는데, 여기서 메모리 공간을 인접한 세트의 위치 들로서 취급하는 것이 더 편리하고, 어드레스 경계는 컴파일 시간에 결정될 수있다.
	    ptr[ 5 ] = 0U;                                              /*      */      /* Compliant     */								
									
	    return 1;								
	}								

Rationale
Array indexing using the array subscript syntax , ptr[expr], is the preferred form of pointer arithmetic because it is often clearer and hence less error prone than pointer manipulation. 
Any explicitly calculated pointer value has the potential to access unintended or invalid memory addresses. 
Such behaviour is also possible with array indexing, but the subscript syntax may ease the task of manual review.
Pointer arithmetic in C can be confusing to the novice. The expression ptr+1 may be mistakenly interpreted as the addition of 1 to the address held in ptr. 
In fact the new memory address depends on the size in bytes of the pointers target. 
배열 첨자 구문 인 ptr [expr]을 사용한 배열 색인화는 포인터 조작보다 더 명확하고 오류가 적기 때문에 포인터 계산의 기본 형식입니다.
명시 적으로 계산 된 포인터 값은 의도하지 않거나 유효하지 않은 메모리 주소에 액세스 할 가능성이 있습니다.
이러한 동작은 배열 인덱싱에서도 가능하지만 아래 첨자 구문을 사용하면 수동 검토 작업이 쉬워 질 수 있습니다.
C에서의 포인터 연산은 초보자에게 혼동을 줄 수 있습니다. 표현 ptr + 1은 실수로 ptr에 보유 된 주소에 1을 더한 것으로 해석 될 수 있습니다.
사실 새 메모리 주소는 포인터 대상의 바이트 크기에 따라 다릅니다.

This misunderstanding can lead to unexpected behaviour if sizeof is applied incorrectly.
When used with caution however, pointer manipulation using ++ can in some cases be considered more natural; 
e.g. sequentially accessing locations during a memory test where it is more convenient to treat the memory space as a contiguous set of locations and the address bounds can be determined at compilation time.
sizeof가 잘못 적용되면 이러한 오해로 인해 예기치 않은 동작이 발생할 수 있습니다.
그러나주의해서 사용하면 ++를 사용하는 포인터 조작이 더 자연스러운 것으로 간주 될 수 있습니다.
예 : 메모리 테스트 동안 메모리 액세스를 순차적으로 액세스하는데, 여기서 메모리 공간을 인접한 세트의 위치 들로서 취급하는 것이 더 편리하고, 어드레스 경계는 컴파일 시간에 결정될 수있다.

Exception
Subject to Rule 18.2, pointer subtraction between two pointers is allowed.
규칙 18.2에 따라 두 포인터 사이의 포인터 빼기가 허용됩니다.

Example
void fn1 ( void )
{
   uint8_t a[ 10 ];
   uint8_t *ptr;
   
   ui nt8_t index = 0U;
   index = index + 1U; /* Compliant - rule only applies to pointers */
   a[ index ] = 0U;      /* Compliant */
   ptr = &a[ 5 ];         /* Compliant */
   ptr = a;
   ptr++;               /* Compliant - increment operator not + */
   *( ptr + 5 ) = 0U; /* Non-compliant */
   ptr[ 5 ] = 0U;      /* Compliant */
}
void fn2 ( void )
{
   uint8_t array_2_2[ 2 ][ 2 ] = { { 1U, 2U }, { 4U, 5U } };
   uint8_t i = 0U;
   uint8_t j = 0U;
   uint8_t sum = 0U;
   for ( i = 0U; i < 2U; i++ )
   {
      uint8_t *row = array_2_2[ i ];
      for ( j = 0U; j < 2U; j++ )
      {
         sum += row[ j ]; /* Compliant */
      }
   }
}
In the following example, Rule 18.1 may also be violated if p1 does not point to an array with at least six elements and p2 does not point to an array with at least 4 elements.
다음 예에서 p1이 최소한 6 개의 요소가있는 배열을 가리키고 p2가 4 개 이상의 요소가있는 배열을 나타내지 않으면 규칙 18.1이 위반 될 수 있습니다.

void fn3 ( uint8_t *p1, uint8_t p2[ ] )
{
   p1++;            /* Compliant */
   p1 = p1 + 5;   /* Non-compliant */
   p1[ 5 ] = 0U;   /* Compliant */
   p2++;            /* Compliant */
   p2 = p2 + 3;   /* Non-compliant */
   p2[ 3 ] = 0U;   /* Compliant */
}
uint8_t a1[ 16 ];
uint8_t a2[ 16 ];
uint8_t data = 0U;
void fn4 ( void )
{
   fn3 ( a1, a2 );
   fn3 ( &data, &a2[ 4 ] );
}

See also
Rule 18.1, Rule 18.2

-----------------------------------------------------------------------------
Rule-18.5									
	Declarations should contain no more than two levels of pointer nesting								
	선언에는 두 단계 이상의 포인터 중첩이 없어야합니다.								
									
	No more than two pointer declarators should be applied consecutively to a type. 
	Any typedef-name appearing in a declaration is treated as if it were replaced by the type that it denotes.								
	두 개 이상의 포인터 선언자는 한 유형에 연속적으로 적용되어야합니다. 
	선언에 나타나는 typedef 이름은 그것이 나타내는 유형으로 대체 된 것처럼 취급됩니다.								
	하나의 유형에 대해 포인터 구분 기호를 연속적으로 두개 이상 적용해서는 안 된다. 
	선언문에 나타나는 모든 형식/이름은 선언문이 나타내는 형식으로 대체된 것으로 간주됩니다.								
									
	Example Code:								
	No more than two pointer declarators should be applied consecutively to a type. 
	Any typedef-name appearing in a declaration is treated as if it were replaced by the type that it denotes.			
	
	The use of more than two levels of pointer nesting can seriously impair the ability to understand the behaviour of the code, and should therefore be avoided.
	
	하나의 유형에 대해 포인터 구분 기호를 연속적으로 두개 이상 적용해서는 안 된다. 
	선언문에 나타나는 모든 형식/이름은 선언문이 나타내는 형식으로 대체된 것으로 간주됩니다.	

	두 단계 이상의 포인터 중첩을 사용하면 코드 동작을 이해하는 능력을 심각하게 손상시킬 수 있으므로 피해야 한다.

	#pragma PRQA_MESSAGES_OFF 2983								
									
	#include "misra.h"					두 개 이상의 포인터 선언자는 한 유형에 연속적으로 적용되어야합니다. 선언에 나타나는 typedef 이름은 그것이 나타내는 유형으로 대체 된 것처럼 취급됩니다.			
	#include "m3cmex.h"					3 단계 이상의 포인터 중첩을 사용하면 코드의 동작을 이해할 수 없으므로 피해야합니다.			
									
						하나의 유형에 대해 포인터 구분 기호를 연속적으로 두개 이상 적용해서는 안 된다. 선언문에 표시되는 형식/이름은 선언문이 나타내는 형식으로 대체된 것처럼 취급됩니다.			
	typedef PC * CHARSTAR;					두가지 이상의 포인터 중첩 수준을 사용하면 코드 동작을 이해하지 못할 수 있으므로 피해야 한다.			
	typedef uint16_t *** PPPU;                          /* 3260 */								
									
	static int16_t rule_1805a( PC ** const ptr[] );     /* 3262 */						<--의미?		 arrPar is of type pointer to pointer to pointer to int8_t because parameters declared with array type are converted to a pointer to the initial element of the array  this is three levels and is non-compliant;
									 arr is of type array of pointer to pointer to int8_t  this is compliant;
	extern int16_t rule_1805( void )								 parr is of type pointer to array of pointer to pointer to int8_t  this is compliant;
	{								 pparr is of type pointer to pointer to array of pointer to int8_t  this is compliant.
	   int16_t     r;								
	   PC          tab[ 4 ];								arrPar는 배열 타입으로 선언 된 매개 변수가 배열의 초기 요소에 대한 포인터로 변환 되었기 때문에 int8_t에 대한 포인터에 대한 포인터 유형 포인터입니다.이 포인터는 세 가지 레벨이며 호환되지 않습니다.
	   PC         *ptr1;								arr은 int8_t에 대한 포인터에 대한 포인터 배열입니다. 이것은 호환됩니다.
	   PC        **ptr2;								parr은 int8_t에 대한 포인터에 대한 포인터의 배열에 대한 포인터 유형입니다.
	   PC       ***ptr3;                                /* 3262 */								pparr은 int8_t에 대한 포인터 배열에 대한 포인터 포인터입니다.
	   CHARSTAR  **ptr4;                                /* 3262 */								
	   CHARSTAR   *const * const ptr5;                  /* 3262 */						<-- 의미?		arrPar는 어레이 유형으로 선언된 매개 변수가 어레이의 초기 요소에 대한 포인터로 변환되기 때문에 int8_t에 포인터로 포인터를 가리키는 유형의 포인터입니다.준수하는
									r는 int8_t에 포인터를 배치하는 포인터 배열 형식입니다. 이는 준수합니다.
	   ptr1 = &tab[ 0 ];								 parr는 inarray_t에 대한 포인터 배열에 대한 포인터 유형입니다. 이는 준수합니다.
	   ptr2 = &ptr1;								tparr는 in._t에 대한 포인터 배열을 가리키는 포인터 형식입니다. 이는 준수합니다.
	   ptr3 = &ptr2;								
									
	   r = rule_1805a( ptr3 );								
									
	   return r;								
	}								
									
	static int16_t rule_1805a( PC ** const ptr[] )      /* 3262 */								
	{								
	   PC cx;								
									
	   cx = ***ptr;								
									
	   return 0;								
	}								
									
									
	typedef int8_t * INTPTR;								
	void function ( int8_t ** arrPar[ ] ) /* Non-compliant */								
	{								
	int8_t ** obj2; /* Compliant */								
	int8_t *** obj3; /* Non-compliant */								
	INTPTR * obj4; /* Compliant */								
	INTPTR * const * const obj5; /* Non-compliant */								
	int8_t ** arr[ 10 ]; /* Compliant */								
	int8_t ** ( *parr )[ 10 ]; /* Compliant */								
	int8_t * ( **pparr )[ 10 ]; /* Compliant */								
	}								
	struct s								
	{								
	int8_t * s1; /* Compliant */								
	int8_t ** s2; /* Compliant */								
	int8_t *** s3; /* Non-compliant */								
	};								
	struct s * ps1; /* Compliant */								
	struct s ** ps2; /* Compliant */								
	struct s *** ps3; /* Non-compliant */								
	int8_t ** ( *pfunc1 )( void ); /* Compliant */			<-- ? 설명필요				
	int8_t ** ( **pfunc2 )( void ); /* Compliant */			<-- ?					
	int8_t ** ( ***pfunc3 )( void ); /* Non-compliant */	<-- ?							
	int8_t *** ( **pfunc4 )( void ); /* Non-compliant */	<-- ?							

	
Rationale
The use of more than two levels of pointer nesting can seriously impair the ability t o understand the
behaviour of the code, and should therefore be avoided.
Example
typedef int8_t * INTPTR;
void function ( int8_t ** arrPar[ ] )   /* Non-compliant */  3 level pointer
{
   int8_t ** obj2;                          /* Compliant */
   int8_t *** obj3;                         /* Non-compliant */
   INTPTR * obj4;                         /* Compliant */
   INTPTR * const * const obj5;       /* Non-compliant */
   int8_t ** arr[ 10 ];                      /* Compliant */
   int8_t ** ( *parr )[ 10 ];               /* Compliant */  포인터에 대한 포인터 배열에 대한 포인터
   int8_t * ( **pparr )[ 10 ];             /* Compliant */   포인터 배열에 대한 포인터에 대한 포인터
}

struct s
{
   int8_t * s1;      /* Compliant */
   int8_t ** s2;     /* Compliant */
   int8_t *** s3;    /* Non-compliant */
};

struct s * ps1;     /* Compliant */
struct s ** ps2;    /* Compliant */
struct s *** ps3;   /* Non-compliant */
int8_t ** ( *pfunc1 )( void );     /* Compliant */     ?
int8_t ** ( **pfunc2 )( void );    /* Compliant */     ?
int8_t ** ( ***pfunc3 )( void );   /* Non-compliant */   ?
int8_t *** ( **pfunc4 )( void );   /* Non-compliant */   ?

Note:
- arrPar is of type pointer to pointer to pointer to int8_t because parameters declared with array type are converted to a pointer to the initial element of the array. : this is three levels and is non-compliant;
- arr is of type array of pointer to pointer to int8_t : this is compliant;
- parr is of type pointer to array of pointer to pointer to int8_t : this is compliant;
- pparr is of type pointer to pointer to array of pointer to int8_t : this is compliant.
arrPar는 배열 유형으로 선언 된 매개 변수가 배열의 초기 요소에 대한 포인터로 변환되므로 int8_t에 대한 포인터에 대한 포인터 유형 포인터입니다 (3 단계이며 호환되지 않습니다). 
arr은 int8_t에 대한 포인터에 대한 포인터 배열 형식입니다 (호환 됨). 
parr은 int8_t에 대한 포인터에 대한 포인터의 배열에 대한 포인터 유형입니다 (호환 됨). 
pparr은 int8_t에 대한 포인터 배열에 대한 포인터에 대한 포인터 유형입니다 (호환 됨).

-----------------------------------------------------------------------------
Rule-19.2	
	The union keyword should not be used.
	union 키워드는 사용하지 말것. 
	
	Example Code:
	
	#include "misra.h"
	#include "m3cmex.h"
	
	typedef union {char x[2]; uint16_t s;} TU;      /* 0750 */
	
	union test
	{                                               /* 0750 */
	   char    *c;
	   int32_t  i;
	};
	
	extern int16_t rule_1902( void )
	{
	   union test mytest;                           /* 0759 */
	   TU         xtr;                              /* 0759 */
	
	   return 0;
	}
	
	uint32_t zext ( uint16_t s )
	{
	   union
	   {
	      uint32_t ul;
	      uint16_t us;
	   } tmp;
	   tmp.us = s;
	   return tmp.ul; /* unspecified value */
	}

	
Rationale
A union member can be written and the same member can then be read back in a well-defined manner.
However, if a union member is written and then a different union member is read back, the behaviour depends on the relative sizes of the members.
- If the member read is wider than the member written then the value is unspecified.
- Otherwise, the value is implementation-defined.
The Standard permits the bytes of a union member to be accessed by means of another member whose type is array of unsigned char. 
However, since it is possible to access bytes with unspecified values, unions should not be used.

Union 멤버변수에 값을 기록하고 동일한 멤버변수로 다시 읽을 수 있습니다.
그러나, 만약 union 멤버변수에 값을 쓰고, 다른 멤버변수로 읽는다면 멤버변수의 상대적 크기에 따라 값이 달라집니다.
- 읽은 멤버변수크기가 작성된 멤버변수보다 클경우 값은 명시되지 않습니다.
- 그렇지 않은경우, 값은 구현정의 입니다.
표준에 따라 형식이 unsigned char 배열 인 다른 멤버를 통해 공용 멤버의 바이트에 액세스 할 수 있습니다.
그러나 지정되지 않은 값으로 바이트에 액세스 할 수 있으므로 유니온을 사용하지 않아야합니다.

If this rule is not followed, the kinds of behaviour that need to be determined are:
- Padding : how much padding is inserted at the end of the union.
- Alignment : how are members of any structures within the union aligned.
- Endianness : is the most significant byte of a word stored at the lowest or highest memory address.
- Bit-order : how are bits numbered within bytes and how are bits allocated to bit fields.
이 규칙을 따르지 않을 경우 확인해야 할 행동 유형은 다음과 같습니다.
- Padding : 유니 코드 끝에 얼마나 많은 패딩이 삽입되는지.
- 정렬 : 유니언 내의 모든 구조의 멤버가 어떻게 정렬됩니까?
- 엔디 언 (Endianness) : 최하위 또는 최상위 메모리 주소에 저장된 워드의 최상위 바이트입니다.
- 비트 순서 : 비트 내에서 비트가 매겨지는 방식과 비트가 비트 필드에 할당되는 방식.

-패딩:유니언의 끝에 삽입되는 패딩의 양.
-정렬:유니언 안에 있는 구조물의 부재들은 어떻게 정렬됩니까?

Example
In this non-compliant example, a 16-bit value is stored into a union but a 32-bit value is read back resulting in an unspecified value being returned.
이 비준수 예제에서는 16 비트 값이 공용체에 저장되지만 32 비트 값이 다시 읽혀 지므로 지정되지 않은 값이 반환됩니다

uint32_t zext ( uint16_t s )
{
   union
   {
      uint32_t ul;
      uint16_t us;
   } tmp;
   tmp.us = s;
   return tmp.ul; /* unspecified value */
}
See also
Rule 19.1


-----------------------------------------------------------------------------
Rule-20.1	
	#include directives should only be preceded by preprocessor directives or comments.
	
	The rule shall be applied to the contents of a file before preprocessing occurs.
	
	#include 지시문 앞에 선행 지시문이나 주석이 있어야합니다. 
	전처리가 일어나기 전에 규칙은 파일의 내용에 적용되어야한다.
	사전 처리가 발생하기 전에 파일 내용에 규칙을 적용해야 한다.
	
	Rationale
	To aid code readability, all the #include directives in a particular code file should be grouped together near the top of the file.
	Additionally, using #include to include a standard header file within a declaration or definition, or using part of The Standard Library before the inclusion of the related standard header file leads to undefined behaviour.
	이론적 해석
	코드 가독성을 높이려면 특정 코드 파일의 모든 #include 지시문을 파일의 맨 위에 함께 그룹화해야합니다.
	또한 #include를 사용하여 선언 또는 정의 내에 표준 헤더 파일을 포함하거나 관련 표준 헤더 파일을 포함하기 전에 표준 라이브러리의 일부를 사용하면 정의되지 않은 동작이 발생합니다.
	
	Example Code:
	
	#include "misra.h"
	#include "m3cmex.h"
	
	extern int16_t rule_2001( void )
	{
	   return 1;
	}
	
	#include "rule-20.01.h"                         /* 5087 */
	
	
	/* f.h */
	xyz = 0;
	/* f.c */
	int16_t
	#include "f.h" /* Non-compliant */
	/* f1.c */
	#define F1_MACRO
	#include "f1.h" /* Compliant */
	#include "f2.h" /* Compliant */
	int32_t i = 0;
	#include "f3.h" /* Non-compliant */


-----------------------------------------------------------------------------
Rule-20.5	
	#undef should not be used
	
	Example Code:
	
	#include "misra.h"
	#include "m3cmex.h"
	
	extern int16_t rule_2005( void )
	{
	    return 1;
	}
	
	#define  L      0
	#undef   L                                      /* 0841 */
	
	
	Rationale
	The use of #undef can make it unclear which macros exist at a particular point within a translation unit.
	#undef를 사용하면 번역 단위 내의 특정 지점에 어떤 매크로가 존재하는지 명확하지 않을 수 있습니다.
	#undef를 사용하면 변환 단위 내의 특정 지점에 어떤 매크로가 존재하는지 명확하지 않을 수 있습니다.
	
	Example
	#define QUALIFIER volatile
	#undef QUALIFIER /* Non-compliant */
	void f ( QUALIFIER int32_t p )
	{
	while ( p != 0 )
	{
	; /* Wait... */
	}
	}

-----------------------------------------------------------------------------
Rule-20.10	
	The # and ## preprocessor operators should not be used.
	
	Rationale
The order of evaluation associated with multiple #, multiple ## or a mix of # and ## preprocessor operators is unspecified. 
In some cases it is therefore not possible to predict the result of macro expansion.
The use of the ## operator can result in code that is obscure.
Note: Rule 1.3 covers the undefined behaviour that arises if either:
- The result of a # operator is not a valid string literal; or
- The result of a ## operator is not a valid preprocessing token.
	
	이론적 해석
	여러 #, 다중 ## 또는 # 및 ## 전 처리기 연산자 조합과 관련된 평가 순서는 지정되지 않습니다.
	따라서 어떤 경우에는 매크로 확장 결과를 예측할 수 없습니다.
	## 연산자를 사용하면 코드가 애매하게 나타날 수 있습니다.
	주 : 규칙 1.3은 다음 중 하나 일 경우 발생하는 정의되지 않은 동작을 다룹니다.
	# 연산자의 결과는 유효한 문자열 리터럴이 아닙니다. 또는
	## 연산자의 결과는 유효한 전처리 토큰이 아닙니다.
	
	여러#, 다중##또는#및##preprocessor연산자 혼합과 관련된 평가 순서는 지정되지 않았습니다. 
	따라서 매크로 확장의 결과를 예측할 수 없는 경우도 있습니다.
	##연산자를 사용하면 코드가 모호할 수 있습니다.
	참고:규칙 1.3은 다음 중 하나에 해당하는 경우에 발생하는 언더 헤드 동작을 다룹니다.
	#연산자의 결과가 유효한 문자열 리터럴이 아닙니다. 또는
	##연산자의 결과는 유효한 사전 처리 토큰이 아닙니다.
	
	
	
	xample Code:
	
	#include "misra.h"
	#include "m3cmex.h"
	
	#define STRINGIFY( S ) #S                       /* 0341 */
	#define GLUE( S1, S2 ) S1 ## S2                 /* 0342 */
	
	extern int16_t rule_2010( void )
	{
	   const char buf[] = STRINGIFY( MISRA );
	   int16_t GLUE( ru, le ) = 1;
	
	   return 0;
	}

See also
Rule 20.11

-----------------------------------------------------------------------------
Rule-21.12	
	The exception handling features of <fenv.h> should not be used.
	<fenv.h> 의 예외처리 기능을 사용하지 말것
	<fenv.h>의 예외 처리 기능을 사용하면 안됩니다.
	Amplification:
	
	The identifiers feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag and fetestexcept shall not be used and no macro with one of these names shall be expanded.
	The macros FE_INEXACT, FE_DIVBYZERO, FE_UNDERFLOW, FE_OVERFLOW, FE_INVALID and FE_ALL_EXCEPT, along with any implementation-defined floating-point exception macros, shall not be used.

	식별자 feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag 및 fetestexcept는 사용되지 않아야하며이 이름 중 하나를 가진 매크로는 확장되지 않습니다. 
	구현 정의 부동 소수점 예외 매크로와 함께 매크로 FE_INEXACT, FE_DIVBYZERO, FE_UNDERFLOW, FE_OVERFLOW, FE_INVALID 및 FE_ALL_EXCEPT는 사용하지 않아야합니다.

	Peclearexcept, Fegetexcept, Fesetexceptflag및 Fetestexcept식별자는 사용할 수 없으며 이러한 이름의 매크로는 사용할 수 없습니다.
	매크로 FE_INEXACT, FE_DIVBERO, FE_UNDErfLOW, FE_UNDEERFlOW, FE_INGILID및 FE_INCEPT예외는 사용되지 않습니다.
	
	Rationale
In some circumstances, the values of the floating-point status flags are unspecified and attempts to access them may lead to undefined behaviour.
The order in which exceptions are raised by the “feraiseexcept” function is unspecified and could therefore result in a program that has been designed for a certain order not operating correctly.
이론적 해석
경우에 따라 부동 소수점 상태 플래그의 값이 지정되지 않았으므로 부동 소수점 상태 플래그에 액세스하려고하면 정의되지 않은 동작이 발생할 수 있습니다.
"feraiseexcept"함수에 의해 예외가 발생하는 순서는 지정되지 않으므로 올바르게 작동하지 않는 특정 순서로 설계된 프로그램이 될 수 있습니다.

일부 상황에서는 부동 소수 점 상태 플래그의 값이 지정되지 않으며 이러한 플래그에 액세스 하려고 하면 정의되지 않은 동작이 발생할 수 있습니다.
"Feraiseexcept"함수에 의해 예외가 발생하는 순서가 지정되지 않았으므로 특정 주문에 대해 설계된 프로그램이 제대로 작동하지 않을 수 있습니다.	

Example Code:
	
	#include <fenv.h>
	
	#include "misra.h"
	#include "m3cmex.h"
	
	extern int16_t rule_2112( void )
	{
	   float32_t z;
	   s16a = feclearexcept( FE_DIVBYZERO );                /* 5136 */
	   z = f32a / f32b;
	   if ( fetestexcept( FE_DIVBYZERO ) != 0 )             /* 5136 */
	   {
	   }
	   else
	   {
	#pragma STDC FENV_ACCESS ON                             /* 3116 */
	       z = f32a * f32b;
	   }
	   if ( z > f32a )
	   {
	#pragma STDC FENV_ACCESS OFF                            /* 3116 */
	       if ( fetestexcept( FE_OVERFLOW ) != 0)           /* 5136 */
	       {
	       }
	   }
	
	   return 1;
	}
