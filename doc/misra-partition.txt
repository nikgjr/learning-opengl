					담당자		서승범	16
CMN-0	Common						박종영	20
		CMN-0_1	Information				신상명	20
				CMN-0.1		Annotations	옥영훈	20
				CMN-0.2		CMA information	우상호	20
				CMN-0.3		Parsing recovery	이대건	20
				CMN-0.4		Dataflow recovery	우재성	20
				CMN-0.5		Sub-Messages	우진석	20
		CMN-0_9	Errors					
				CMN-9.1		QAC configuration	총개수	156
				CMN-9.2		Syntax errors		
M3CM-1	MISRA Mandatory							
		M3CM-1_1	Rules					
				Rule-9.1	서승범	The value of an object with automatic storage duration shall not be read before it has been set		
				Rule-12.5	서승범	The sizeof operator shall not have an operand which is a function parameter declared as 'array of type'		
				Rule-13.6	서승범	The operand of the sizeof operator shall not contain any expression which has potential side-effects		
				Rule-17.3	서승범	A function shall not be declared implicitly		
				Rule-17.4	서승범	All exit paths from a function with non-void return type shall have an explicit return statement with an expression		
				Rule-17.6	서승범	The declaration of an array parameter shall not contain the static keyword between the [ ]		
				Rule-19.1	서승범	An object shall not be assigned or copied to an overlapping object		
				Rule-21.13	서승범	Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the value EOF		
				Rule-21.17	서승범	Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters		
				Rule-21.18	서승범	The size_t argument passed to any function in <string.h> shall have an appropriate value		
				Rule-21.19	서승범	The pointers returned by the Standard Library functions lovaleconv, getenv, setlocale or strerror shall only be used as if they have pointer to const-qualified type		
				Rule-21.20	서승범	The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale, or strerror shall not be used following a subsequent call to the same function		
				Rule-22.2	서승범	A block of memory shall only be freed if it was allocated by means of a Standard Library function		
				Rule-22.4	서승범	There shall be no attempt to write to a stream which has been opened as read-only		
				Rule-22.5	서승범	A pointer to a FILE object shall not be dereferenced		
				Rule-22.6	서승범	The value of a pointer to a FILE shall not be used after the associated stream has been closed		
M3CM-2	MISRA Required							
		M3CM-2_1	Rules					
				Rule-1.1	박종영	The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation's translation limits		
				Rule-1.3	박종영	There shall be no occurrence of undefined or critical unspecified behaviour		
				Rule-2.1	박종영	A project shall not contain unreachable code		
				Rule-2.2	박종영	There shall be no dead code		
				Rule-3.1	박종영	The character sequences /* and // shall not be used within a comment.		
				Rule-3.2	박종영	Line-splicing shall not be used in // comments.		
				Rule-4.1	박종영	Octal and hexadecimal escape sequences shall be terminated		
				Rule-5.1	박종영	External identifiers shall be distinct		
				Rule-5.2	박종영	Identifiers declared in the same scope and name space shall be distinct		
				Rule-5.3	박종영	An identifier declared in an inner scope shall not hide an identifier declared in an outer scope		
				Rule-5.4	박종영	Macro identifiers shall be distinct		
				Rule-5.5	박종영	Identifiers shall be distinct from macro names		
				Rule-5.6	박종영	A typedef name shall be a unique identifier		
				Rule-5.7	박종영	A tag name shall be a unique identifier		
				Rule-5.8	박종영	Identifiers that define objects or functions with external linkage shall be unique		
				Rule-6.1	박종영	Bit-fields shall only be declared with an appropriate type		
				Rule-6.2	박종영	Single-bit named bit fields shall not be of a signed type		
				Rule-7.1	박종영	Octal constants shall not be used		
				Rule-7.2	박종영	A "u" or "U" suffix shall be applied to all integer constants that are represented in an unsigned type		
				Rule-7.3	박종영	The lowercase character "l" shall not be used in a literal suffix		
				Rule-7.4	신상명	A string literal shall not be assigned to an object unless the object's type is "pointer to const-qualified char"		
				Rule-8.1	신상명	Types shall be explicitly specified		
				Rule-8.2	신상명	Function types shall be in prototype form with named parameters		
				Rule-8.3	신상명	All declarations of an object or function shall use the same names and type qualifiers		
				Rule-8.4	신상명	A compatible declaration shall be visible when an object or function with external linkage is defined		
				Rule-8.5	신상명	An external object or function shall be declared once in one and only one file		
				Rule-8.6	신상명	An identifier with external linkage shall have exactly one external definition		
				Rule-8.8	신상명	The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage		
				Rule-8.10	신상명	An inline function shall be declared with the static storage class		
				Rule-8.12	신상명	Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique		
				Rule-8.14	신상명	The restrict type qualifier shall not be used		
				Rule-9.2	신상명	The initializer for an aggregate or union shall be enclosed in braces		
				Rule-9.3	신상명	Arrays shall not be partially initialized		
				Rule-9.4	신상명	An element of an object shall not be initialized more than once		
				Rule-9.5	신상명	Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly		
				Rule-10.1	신상명	Operands shall not be of an inappropriate essential type.		
				Rule-10.2	신상명	Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations		
				Rule-10.3	신상명	The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category.		
				Rule-10.4	신상명	Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category		
				Rule-10.6	신상명	The value of a composite expression shall not be assigned to an object with wider essential type		
				Rule-10.7	옥영훈	If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type		
				Rule-10.8	옥영훈	The value of a composite expression shall not be cast to a different essential type category or a wider essential type		
				Rule-11.1	옥영훈	Conversions shall not be performed between a pointer to a function and any other type		
				Rule-11.2	옥영훈	Conversions shall not be performed between a pointer to an incomplete type and any other type		
				Rule-11.3	옥영훈	A cast shall not be performed between a pointer to object type and a pointer to a different object type		
				Rule-11.6	옥영훈	A cast shall not be performed between pointer to void and an arithmetic type		
				Rule-11.7	옥영훈	A cast shall not be performed between pointer to object and a non-integer arithmetic type		
				Rule-11.8	옥영훈	A cast shall not remove any const or volatile qualification from the type pointed to by a pointer		
				Rule-11.9	옥영훈	The macro NULL shall be the only permitted form of integer null pointer constant		
				Rule-12.2	옥영훈	The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand		
				Rule-13.1	옥영훈	Initializer lists shall not contain persistent side-effects		
				Rule-13.2	옥영훈	The value of an expression and its persistent side-effects shall be the same under all permitted evaluation orders		
				Rule-13.5	옥영훈	The right hand operand of a logical && or || operator shall not contain persistent side effects		
				Rule-14.1	옥영훈	A loop counter shall not have essentially floating type		
				Rule-14.2	옥영훈	A for loop shall be well-formed		
				Rule-14.3	옥영훈	Controlling expressions shall not be invariant		
				Rule-14.4	옥영훈	The controlling expression of an if-statement and the controlling expression of an iteration-statement shall have essentially Boolean type		
				Rule-15.2	옥영훈	The goto statement shall jump to a label declared later in the same function		
				Rule-15.3	옥영훈	Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement		
				Rule-15.6	옥영훈	The body of an iteration-statement or a selection-statement shall be a compound-statement		
				Rule-15.7	우상호	All if ... else if constructs shall be terminated with an else statement		
				Rule-16.1	우상호	All switch statements shall be well-formed		
				Rule-16.2	우상호	A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement		
				Rule-16.3	우상호	An unconditional break statement shall terminate every switch-clause		
				Rule-16.4	우상호	Every switch statement shall have a default label		
				Rule-16.5	우상호	A default label shall appear as either the first or the last switch label of a switch statement		
				Rule-16.6	우상호	Every switch statement shall have at least two switch-clauses		
				Rule-16.7	우상호	A switch-expression shall not have essentially Boolean type		
				Rule-17.1	우상호	The features of <stdarg.h> shall not be used		
				Rule-17.2	우상호	Functions shall not call themselves, either directly or indirectly		
				Rule-17.7	우상호	The value returned by a function having non-void return type shall be used		
				Rule-18.1	우상호	A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand		
				Rule-18.2	우상호	Subtraction between pointers shall only be applied to pointers that address elements of the same array		
				Rule-18.3	우상호	The relational operators >, >=, < and <= shall not be applied to objects of pointer type except where they point into the same object		
				Rule-18.6	우상호	The address of an object with automatic storage shall not be copied to another object that persists after the first object has ceased to exist		
				Rule-18.7	우상호	Flexible array members shall not be declared		
				Rule-18.8	우상호	Variable-length array types shall not be used		
				Rule-20.2	우상호	The ', " or \ characters and the /* or // character sequences shall not occur in a header file name		
				Rule-20.3	우상호	The #include directive shall be followed by either a <filename> or "filename" sequence		
				Rule-20.4	우상호	A macro shall not be defined with the same name as a keyword		
				Rule-20.6	이대건	Tokens that look like a preprocessing directive shall not occur within a macro argument		
				Rule-20.7	이대건	Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses		
				Rule-20.8	이대건	The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1		
				Rule-20.9	이대건	All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation		
				Rule-20.11	이대건	A macro parameter immediately following a # operator shall not immediately be followed by a ## operator		
				Rule-20.12	이대건	A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators		
				Rule-20.13	이대건	A line whose first token is # shall be a valid preprocessing directive		
				Rule-20.14	이대건	All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related		
				Rule-21.1	이대건	#define and #undef shall not be used on a reserved identifier or reserved macro name		
				Rule-21.2	이대건	A reserved identifier or macro name shall not be declared		
				Rule-21.3	이대건	The memory allocation and deallocation functions of <stdlib.h> shall not be used		
				Rule-21.4	이대건	The standard header file <setjmp.h> shall not be used		
				Rule-21.5	이대건	The standard header file <signal.h> shall not be used		
				Rule-21.6	이대건	The Standard Library input/output functions shall not be used		
				Rule-21.7	이대건	The atof, atoi, atol and atoll functions of <stdlib.h> shall not be used		
				Rule-21.8	이대건	The library functions abort, exit and system of <stdlib.h> shall not be used		
				Rule-21.9	이대건	The library functions bsearch and qsort of <stdlib.h> shall not be used		
				Rule-21.10	이대건	The Standard Library time and date functions shall not be used		
				Rule-21.11	이대건	The standard header file <tgmath.h> shall not be used		
				Rule-21.14	이대건	The Standard Library function memcmp shall not be used to compare null terminated strings		
				Rule-21.15	우재성	The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types		
				Rule-21.16	우재성	The pointer arguments to the Standard Library function memcpy shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type		
				Rule-22.1	우재성	All resources obtained dynamically by means of Standard Library functions shall be explicitly released		
				Rule-22.3	우재성	The same file shall not be open for read and write access at the same time on different streams		
				Rule-22.7	우재성	The macro EOF shall on ly be compared with the unmodified return value from any Standard Library function capable of returning EOF		
				Rule-22.8	우재성	The value of errno shall be set to zero prior to a call to an errno-setting-function		
				Rule-22.9	우재성	The value of errno shall be tested against zero after calling an errno-setting-function		
				Rule-22.10	우재성	The value of errno shall only be tested when the last function to be called was an errno-setting-function		
		M3CM-2_2	Directives					
				Dir-1.1		Any implementation-defined behaviour on which the output of the program depends shall be documented and understood		
				Dir-2.1		All source files shall compile without any compilation errors		
				Dir-3.1		All code shall be traceable to documented requirements		
				Dir-4.1		Run-time failures shall be minimized		
				Dir-4.3		Assembly language shall be encapsulated and isolated		
				Dir-4.7		If a function returns error information, then that error information shall be tested		
				Dir-4.10		Precautions shall be taken in order to prevent the contents of a header file being included more then once		
				Dir-4.11		The validity of values passed to library functions shall be checked		
				Dir-4.12		Dynamic memory allocation shall not be used		
				Dir-4.14		The validity of values received from external sources shall be checked		
M3CM-3	MISRA Advisory							
		M3CM-3_1	Rules					
				Rule-1.2	우재성	Language extensions should not be used		
				Rule-2.3	우재성	A project should not contain unused type declarations		
				Rule-2.4	우재성	A project should not contain unused tag declarations		
				Rule-2.5	우재성	A project should not contain unused macro declarations		
				Rule-2.6	우재성	A function should not contain unused label declarations		
				Rule-2.7	우재성	There should be no unused parameters in functions		
				Rule-4.2	우재성	Trigraphs should not be used		
				Rule-5.9	우재성	Identifiers that define objects or functions with internal linkage should be unique		
				Rule-8.7	우재성	Functions and objects should not be defined with external linkage if they are referenced in only one translation unit		
				Rule-8.9	우재성	An object should be defined at block scope if its identifier only appears in a single function		
				Rule-8.11	우재성	When an array with external linkage is declared, its size should be explicitly specified		
				Rule-8.13	우재성	A pointer should point to a const-qualified type whenever possible		
				Rule-10.5	우진석	The value of an expression should not be cast to an inappropriate essential type		
				Rule-11.4	우진석	A conversion should not be performed between a pointer to object and an integer type		
				Rule-11.5	우진석	A conversion should not be performed from pointer to void into pointer to object		
				Rule-12.1	우진석	The precedence of operators within expressions should be made explicit		
				Rule-12.3	우진석	The comma operator should not be used		
				Rule-12.4	우진석	Evaluation of constant expressions should not lead to unsigned integer wrap-around		
				Rule-13.3	우진석	A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator		
				Rule-13.4	우진석	The result of an assignment operator should not be used		
				Rule-15.1	우진석	The goto statement should not be used		
				Rule-15.4	우진석	There should be no more than one break or goto statement used to terminate any iteration statement		
				Rule-15.5	우진석	A function should have a single point of exit at the end		
				Rule-17.5	우진석	The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements		
				Rule-17.8	우진석	A function parameter should not be modified		
				Rule-18.4	우진석	The +, -, += and -= operators should not be applied to an expression of pointer type		
				Rule-18.5	우진석	Declarations should contain no more than two levels of pointer nesting		
				Rule-19.2	우진석	The union keyword should not be used		
				Rule-20.1	우진석	#include directives should only be preceded by preprocessor directives or comments		
				Rule-20.5	우진석	#undef should not be used		
				Rule-20.10	우진석	The # and ## preprocessor operators should not be used		
				Rule-21.12	우진석	The exception handling features of <fenv.h> should not be used		
		M3CM-3_2	Directives					
				Dir-4.2		All usage of assembly language should be documented		
				Dir-4.4		Sections of code should not be "commented out"		
				Dir-4.5		Identifiers in the same name space with overlapping visibility should be typographically unambiguous		
				Dir-4.6		typedefs that indicate size and signedness should be used in place of the basic numerical types		
				Dir-4.8		If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden		
				Dir-4.9		A function should be used in preference to a function-like macro where they are interchangeable		
				Dir-4.13		Functions which are designed to provide operations on a resource should be called in an appropriate sequence		
